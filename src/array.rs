//! A heap allocated array.

use std::{
    alloc::{Layout, alloc, dealloc, handle_alloc_error},
    fmt::Debug,
    mem::{ManuallyDrop, MaybeUninit, needs_drop},
    ops::{Deref, DerefMut, Index, IndexMut},
    ptr::{self, NonNull, copy_nonoverlapping, drop_in_place},
    slice::{from_raw_parts, from_raw_parts_mut},
};

/// Type alias for an array that might have uninitialized values.
pub type MaybeUninitArray<T> = Array<MaybeUninit<T>>;

/// A macro to initialize a the heap allocated array with an array like syntax.
///
/// # Syntax
///
/// * `array![]` create an empty array that does no heap allocations.
/// * `array![32; 5]` create an array of length 5 with all elements as 32.
/// * `array![1, 2, 3]` create an array of length 3 with elements 1, 2 and 3.
///
/// # Examples
///
/// Array with zero length.
///
/// ```
/// # use structures::{array, Array};
/// let vec: Vec<u64> = vec![];
/// let array: Array<u64> = array![];
/// assert_eq!(vec, array);
/// ```
///
/// Array from cloning an element N times.
///  
/// ```
/// # use structures::array;
/// let vec = vec![32; 5];
/// let array = array![32; 5];
/// assert_eq!(vec, array);
///```
///
/// Array from literal array elements.
///
/// ```
///# use structures::array;
/// let vec = vec![1, 2, 3];
/// let array = array![1, 2, 3];
/// assert_eq!(vec, array);
/// ```
#[macro_export]
macro_rules! array {
    () => {
        $crate::Array::default()
    };

    ($elem:expr; $n:expr) => {
        $crate::Array::from_fn($n, |_| $elem)
    };

    ($($x:expr),+ $(,)?) => {
        $crate::Array::from([$($x),+])
    };
}

/// An array that uses memory allocated on the heap.
///
/// An array can be thought of as a [`Vec`] that cannot be re-sized, I mean that's
/// exactly what it is. Array is just way simpler, cause it doesn't have to deal
/// with any re-sizing.
///
/// # Layout
///
/// An array is and always will be (ptr, len) tuple. Actual size on the stack
/// depends on the platform this array is created in, obviously.
///
/// * `len` - Number of elements in the array.
/// * `ptr` - Pointer to allocated memory or [`NonNull::dangling`] if no allocation is necessary.
///
/// # Allocations
///
/// * Uses registered global allocator if present or std allocator.
/// * Zero sized types performs no allocations, regardless of array capacity.
/// * Array with length 0 performs no allocations.
/// * A minimum `size_of::<T> * len` bytes is allocated for the array.
pub struct Array<T> {
    len: usize,
    ptr: NonNull<T>,
}

impl<T> Array<T> {
    /// Create a new array of length zero.
    ///
    /// Note that this does not perform any heap allocation (similar to [`Vec::new`]).
    ///
    /// # Example
    ///
    /// ```
    /// # use structures::Array;
    /// let vec = Vec::<u64>::new();
    /// let array = Array::<u64>::new();
    /// assert_eq!(vec, array);
    /// ```
    #[inline]
    pub const fn new() -> Self {
        Self {
            len: 0,
            ptr: NonNull::dangling(),
        }
    }

    /// Create an array with uninitialized elements.
    ///
    /// Not to be confused with [`None`], truly uninitialized memory. And obviously
    /// any access to such elements requires the use of unsafe, with the exception
    /// of (very few) safe wrappers. Importantly it's your responsibility to execute
    /// drop on initialized elements (if not trivially droppable).
    ///
    /// # Arguments
    ///
    /// * `len` - Length of the array.
    ///
    /// # Example
    ///
    /// ```
    /// # use structures::Array;
    /// // Create a new uninitialized array.
    /// let mut array = Array::<Vec<u8>>::uninit(10);
    ///
    /// // Initialize the array.
    /// for elem in &mut array {
    ///     elem.write(Vec::new());
    /// }
    ///
    /// // Make sure array is initialized correctly.
    /// // Requires unsafe because compiler cannot validate the value
    /// // is initialized, it has to assume.
    /// for elem in &array {
    ///     let val = unsafe {elem.assume_init_ref()};
    ///     assert!(val.is_empty());
    /// }
    /// ```
    #[inline]
    pub fn uninit(len: usize) -> MaybeUninitArray<T> {
        Array::from_fn(len, |_| MaybeUninit::uninit())
    }

    /// Create an array all initially filled with elements generated by a generator.
    ///
    /// # Arguments
    ///
    /// * `len` - Length of the array.
    /// * `f` - A generator of type T that gets index as argument.
    ///
    /// # Example
    ///
    /// ```
    /// # use std::num::NonZeroU64;
    /// # use structures::Array;
    /// // Create a new array initialized with a value generated by the generator.
    /// let array = Array::from_fn(10, |i| NonZeroU64::new(i as _));
    ///
    /// // Make sure array has expected values.
    /// for i in 0..array.len() {
    ///     let elem = array[i];
    ///     assert_eq!(elem, NonZeroU64::new(i as _));
    /// }
    /// ```
    #[inline]
    pub fn from_fn<F>(len: usize, f: F) -> Self
    where
        F: Fn(usize) -> T,
    {
        // Zero sized types do not need heap allocations.
        if size_of::<T>() == 0 || len == 0 {
            return Self {
                len,
                ptr: NonNull::dangling(),
            };
        }

        // Allocate memory on heap to store elements of the array.
        let layout = Layout::array::<T>(len).expect("Allocation too large: > isize::MAX");
        let ptr = NonNull::new(unsafe { alloc(layout) } as *mut T)
            .unwrap_or_else(|| handle_alloc_error(layout));

        // Safety: We are just initializing uninitialized memory.
        // Nothing exists already to drop.
        for i in 0..len {
            unsafe {
                ptr::write(ptr.as_ptr().add(i), f(i));
            };
        }

        Self { ptr, len }
    }
}

impl<T: Copy> MaybeUninitArray<T> {
    /// Copy elements from a slice into the array.
    ///
    /// This allows for optimizing performance for copy types that can
    /// be memcpy'd rather than working on element by element.
    ///
    /// # Panic
    ///
    /// * If the slice overflows bounds of the array.
    ///
    /// # Arguments
    ///
    /// * `index` - Index to start writes.
    /// * `elems` - Elements to copy into array.
    ///
    /// # Examples
    ///
    /// ```
    /// # use structures::Array;
    /// // Create an uninitialized array.
    /// let mut array = Array::uninit(10);
    ///
    /// // Copy elements into the array.
    /// let elems: Vec<_> = (0..10).collect();
    /// array.copy_from_slice(0, &elems);
    ///
    /// // Make sure elements are copied correctly.
    /// for (maybe_elem, elem) in array.iter().zip(&elems) {
    ///     let definitely_elem = unsafe { maybe_elem.assume_init_ref() };
    ///     assert_eq!(elem, definitely_elem);
    /// }
    /// ```
    #[inline]
    pub fn copy_from_slice(&mut self, index: usize, elems: &[T]) {
        assert!(index + elems.len() <= self.len, "Copy overflow");

        // Safety: Copy types are trivially droppable. So they do not
        // have any custom drop glue code. So overwriting memory should
        // be okay. If not overwriting existing elements, no problem,
        // we are just initializing memory.
        unsafe {
            let src = elems.as_ptr();
            let dst = self.ptr.as_ptr().add(index) as *mut _;
            copy_nonoverlapping(src, dst, elems.len());
        }
    }
}

// Safety: Access to the array is protected by the right immutable and mutable
// reference. So an array can be Send/Sync if it's element is.
unsafe impl<T: Send> Send for Array<T> {}
unsafe impl<T: Sync> Sync for Array<T> {}

impl<T> Default for Array<T> {
    #[inline]
    fn default() -> Self {
        Array::new()
    }
}

impl<T> Index<usize> for Array<T> {
    type Output = T;

    #[inline]
    fn index(&self, index: usize) -> &Self::Output {
        &self.as_ref()[index]
    }
}

impl<T> IndexMut<usize> for Array<T> {
    #[inline]
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        &mut self.as_mut()[index]
    }
}

impl<'a, T> IntoIterator for &'a Array<T> {
    type Item = &'a T;
    type IntoIter = std::slice::Iter<'a, T>;

    #[inline]
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

impl<'a, T> IntoIterator for &'a mut Array<T> {
    type Item = &'a mut T;
    type IntoIter = std::slice::IterMut<'a, T>;

    #[inline]
    fn into_iter(self) -> Self::IntoIter {
        self.iter_mut()
    }
}

impl<T> From<Vec<T>> for Array<T> {
    #[inline]
    fn from(value: Vec<T>) -> Self {
        // To make sure vec is not dropped.
        // Elements are semantically moved into the array.
        // Drop will be run (if any) when the array gets dropped.
        let mut vec = ManuallyDrop::new(value);

        // Decompose the vec into pure pointer and length.
        let len = vec.len();
        let ptr = NonNull::new(vec.as_mut_ptr())
            .expect("Vec pointer should be non-null, len correct and properly aligned");

        Self { ptr, len }
    }
}

impl<T, const N: usize> From<[T; N]> for Array<T> {
    #[inline]
    fn from(value: [T; N]) -> Self {
        let ptr = Box::into_raw(Box::new(value));
        let ptr = NonNull::new(ptr as *mut T)
            .expect("Box pointer should be non-null and properly aligned");

        Self { ptr, len: N }
    }
}

impl<T: Clone> From<&[T]> for Array<T> {
    #[inline]
    fn from(value: &[T]) -> Self {
        // Could we just memcpy everything in one shot?
        Array::from_fn(value.len(), |i| value[i].clone())
    }
}

impl<T: Clone> Clone for Array<T> {
    #[inline]
    fn clone(&self) -> Self {
        Array::from(self.as_ref())
    }
}

impl<T: Eq> Eq for Array<T> {}

impl<T: PartialEq> PartialEq for Array<T> {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.as_ref().eq(other.as_ref())
    }
}

impl<T: PartialEq> PartialEq<Vec<T>> for Array<T> {
    #[inline]
    fn eq(&self, other: &Vec<T>) -> bool {
        self.as_ref().eq(other.as_slice())
    }
}

impl<T: PartialEq> PartialEq<Array<T>> for Vec<T> {
    #[inline]
    fn eq(&self, other: &Array<T>) -> bool {
        self.as_slice().eq(other.as_ref())
    }
}

impl<T: PartialEq, const N: usize> PartialEq<[T; N]> for Array<T> {
    #[inline]
    fn eq(&self, other: &[T; N]) -> bool {
        self.as_ref().eq(other)
    }
}

impl<T: PartialEq, const N: usize> PartialEq<Array<T>> for [T; N] {
    #[inline]
    fn eq(&self, other: &Array<T>) -> bool {
        self.eq(other.as_ref())
    }
}

impl<T: Debug> Debug for Array<T> {
    #[inline]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_list().entries(self.iter()).finish()
    }
}

impl<T> Deref for Array<T> {
    type Target = [T];

    #[inline]
    fn deref(&self) -> &Self::Target {
        // Safety: Pointer is non-null and len is correct and immutable.
        unsafe { from_raw_parts(self.ptr.as_ptr(), self.len) }
    }
}

impl<T> DerefMut for Array<T> {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        // Safety: Pointer is non-null and len is correct and immutable.
        unsafe { from_raw_parts_mut(self.ptr.as_ptr(), self.len) }
    }
}

impl<T> Drop for Array<T> {
    #[inline]
    fn drop(&mut self) {
        // Safety: Pointer is non-null and len is correct and immutable.
        unsafe {
            // If the type has drop, we have to execute drop to prevent resource leaks.
            if needs_drop::<T>() {
                drop_in_place(self.as_mut());
            }

            // Memory should be freed only when we actually allocated some memory.
            if self.len != 0 && size_of::<T>() > 0 {
                let layout = Layout::array::<T>(self.len).expect("Layout should be valid");
                dealloc(self.ptr.as_ptr() as *mut u8, layout);
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use bolero::{TypeGenerator, check};
    use rstest::rstest;
    use std::{num::NonZeroU64, ops::Bound, panic::RefUnwindSafe};

    const MAX_SIZE: usize = 1024 * 1024; // 1 MB

    /// Test with sized trivially droppable type.
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    struct Seqno(NonZeroU64);

    impl TypeGenerator for Seqno {
        fn generate<D: bolero::Driver>(driver: &mut D) -> Option<Self> {
            driver
                .gen_u64(Bound::Included(&1), Bound::Unbounded)
                .and_then(NonZeroU64::new)
                .map(Seqno)
        }
    }

    /// Test with type that is not trivially droppable.
    #[derive(Debug, Clone, PartialEq, Eq, TypeGenerator)]
    struct Bytes(Vec<u8>);

    /// Test with zero sized type.
    #[derive(Debug, Copy, Clone, PartialEq, Eq, TypeGenerator)]
    struct Zst;

    // Just cause it gets tiring to add these trait bounds.
    trait Elem: Clone + Debug + PartialEq + RefUnwindSafe + TypeGenerator {}
    impl<T: Clone + Debug + PartialEq + RefUnwindSafe + TypeGenerator> Elem for T {}

    #[test]
    fn zst_state_machine() {
        test_state_machine::<Zst>();
    }

    #[test]
    fn seqno_state_machine() {
        test_state_machine::<Seqno>();
    }

    #[rstest]
    fn bytes_state_machine() {
        test_state_machine::<Bytes>();
    }

    fn test_state_machine<T: Elem>() {
        check!()
            .with_max_len(MAX_SIZE)
            .with_type::<(Vec<Option<T>>, T)>()
            .for_each(|(oracle, val)| {
                let mut array = Array::from(oracle.clone());
                let mut array_1 = Array::from(oracle.as_slice());

                // Make sure everything is equivalent to one another.
                assert_eq!(&array, &array_1);
                assert_eq!(&array, oracle);
                assert_eq!(format!("{oracle:?}"), format!("{array:?}"));
                assert_eq!(format!("{oracle:#?}"), format!("{array:#?}"));

                // Mutate all the elements in the array.
                for elem in &mut array {
                    elem.replace(val.clone());
                    assert_eq!(elem.as_ref(), Some(val));
                }

                for elem in &mut array_1 {
                    elem.take();
                    assert_eq!(elem.as_ref(), None);
                }

                // Make sure mutation is still visible.
                for elem in &array {
                    assert_eq!(elem.as_ref(), Some(val));
                }

                for elem in &array_1 {
                    assert_eq!(elem.as_ref(), None);
                }
            });
    }
}
