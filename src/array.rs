//! A collection of elements with fixed capacity.

mod lazy;

use std::{
    alloc::{Layout, alloc, dealloc, handle_alloc_error},
    fmt::Debug,
    mem::{ManuallyDrop, MaybeUninit, needs_drop},
    ops::{Deref, DerefMut, Index, IndexMut},
    ptr::{self, NonNull, drop_in_place},
    slice::{SliceIndex, from_raw_parts, from_raw_parts_mut},
};

/// Type alias for an Array that may have uninitialized values.
pub type LazyArray<T> = Array<MaybeUninit<T>>;

/// Initialize an [`Array`] with array like syntax.
///
/// # Syntax
///
/// * `array![]` create an empty array that does no heap allocations.
/// * `array![32; 5]` create an array of length 5 with all elements as 32.
/// * `array![1, 2, 3]` create an array of length 3 with elements 1, 2 and 3.
///
/// # Examples
///
/// Array with zero length.
///
/// ```
/// # use structures::{array, Array};
/// let stack: [u64; _] = [];
/// let heap: Array<u64> = array![];
/// assert_eq!(stack, heap);
/// ```
///
/// Array from cloning an element N times.
///  
/// ```
/// # use structures::array;
/// let stack = [32; 5];
/// let heap = array![32; 5];
/// assert_eq!(stack, heap);
///```
///
/// Array from literal array elements.
///
/// ```
///# use structures::array;
/// let stack = [1, 2, 3];
/// let heap = array![1, 2, 3];
/// assert_eq!(stack, heap);
/// ```
#[macro_export]
macro_rules! array {
    () => {
        $crate::Array::default()
    };

    ($elem:expr; $n:expr) => {
        $crate::Array::from_fn($n, |_| $elem)
    };

    ($($x:expr),+ $(,)?) => {
        $crate::Array::from([$($x),+])
    };
}

/// A fixed length collection of elements held in contagious memory segment.
///
/// # Layout
///
/// An array is and always will be (ptr, len) tuple. Actual size on the stack
/// depends on the platform this array is created in, obviously.
///
/// * `len` - Number of elements in the array.
/// * `ptr` - Pointer to allocated memory or [`NonNull::dangling`] if no allocation is necessary.
///
/// # Allocations
///
/// * Uses registered global allocator if present or std allocator.
/// * Zero sized types performs no allocations, regardless of array capacity.
/// * Array with length 0 performs no allocations.
/// * A minimum `size_of::<T> * len` bytes is allocated for the array.
pub struct Array<T> {
    len: usize,
    ptr: NonNull<T>,
}

impl<T> Array<T> {
    /// Create a new array of length zero.
    ///
    /// Note that this does not perform any heap allocation (similar to [`Vec::new`]).
    ///
    /// # Example
    ///
    /// ```
    /// # use structures::Array;
    /// let vec = Vec::<u64>::new();
    /// let array = Array::<u64>::new();
    /// assert_eq!(vec, array);
    /// ```
    #[inline]
    pub const fn new() -> Self {
        Self {
            len: 0,
            ptr: NonNull::dangling(),
        }
    }

    /// Create an array with uninitialized elements.
    ///
    /// Not to be confused with [`None`], truly uninitialized memory. And obviously
    /// any access to such elements requires the use of unsafe, with the exception
    /// of (very few) safe wrappers. Importantly it's your responsibility to execute
    /// drop on initialized elements (if not trivially droppable).
    ///
    /// # Arguments
    ///
    /// * `len` - Length of the array.
    ///
    /// # Example
    ///
    /// ```
    /// # use structures::Array;
    /// // Create a new uninitialized array.
    /// let mut array = Array::<Vec<u8>>::lazy(10);
    ///
    /// // Initialize the array.
    /// for elem in &mut array {
    ///     elem.write(Vec::new());
    /// }
    ///
    /// // Make sure array is initialized correctly.
    /// // Requires unsafe because compiler cannot validate the value
    /// // is initialized, it has to assume.
    /// for elem in &array {
    ///     let val = unsafe { elem.assume_init_ref() };
    ///     assert!(val.is_empty());
    /// }
    /// ```
    #[inline]
    pub fn lazy(len: usize) -> LazyArray<T> {
        Array::from_fn(len, |_| MaybeUninit::uninit())
    }

    /// Create an array all initially filled with elements generated by a generator.
    ///
    /// # Arguments
    ///
    /// * `len` - Length of the array.
    /// * `f` - A generator of type T that gets index as argument.
    ///
    /// # Example
    ///
    /// ```
    /// # use std::num::NonZeroU64;
    /// # use structures::Array;
    /// // Create a new array initialized with a value generated by the generator.
    /// let heap = Array::from_fn(10, |i| NonZeroU64::new(i as _));
    /// let stack: [_; 10] = std::array::from_fn(|i| NonZeroU64::new(i as _));
    /// assert_eq!(stack, heap);
    /// ```
    #[inline]
    pub fn from_fn<F>(len: usize, f: F) -> Self
    where
        F: Fn(usize) -> T,
    {
        // Zero sized types do not need heap allocations.
        if size_of::<T>() == 0 || len == 0 {
            return Self {
                len,
                ptr: NonNull::dangling(),
            };
        }

        // Allocate memory on heap to store elements of the array.
        let layout = Layout::array::<T>(len).expect("Allocation too large: > isize::MAX");
        let ptr = NonNull::new(unsafe { alloc(layout) } as *mut T)
            .unwrap_or_else(|| handle_alloc_error(layout));

        // Safety: We are just initializing uninitialized memory.
        // Nothing exists already to drop.
        for i in 0..len {
            unsafe {
                ptr::write(ptr.as_ptr().add(i), f(i));
            };
        }

        Self { ptr, len }
    }
}

// Safety: Access to the array is protected by the right immutable and mutable
// reference. So an array can be Send/Sync if it's element is.
unsafe impl<T: Send> Send for Array<T> {}
unsafe impl<T: Sync> Sync for Array<T> {}

impl<T> Default for Array<T> {
    #[inline]
    fn default() -> Self {
        Array::new()
    }
}

impl<T, Idx> Index<Idx> for Array<T>
where
    Idx: SliceIndex<[T]>,
{
    type Output = Idx::Output;

    #[inline]
    fn index(&self, index: Idx) -> &Self::Output {
        &self.as_ref()[index]
    }
}

impl<T, Idx> IndexMut<Idx> for Array<T>
where
    Idx: SliceIndex<[T]>,
{
    #[inline]
    fn index_mut(&mut self, index: Idx) -> &mut Self::Output {
        &mut self.as_mut()[index]
    }
}

impl<'a, T> IntoIterator for &'a Array<T> {
    type Item = &'a T;
    type IntoIter = std::slice::Iter<'a, T>;

    #[inline]
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

impl<'a, T> IntoIterator for &'a mut Array<T> {
    type Item = &'a mut T;
    type IntoIter = std::slice::IterMut<'a, T>;

    #[inline]
    fn into_iter(self) -> Self::IntoIter {
        self.iter_mut()
    }
}

impl<T> From<Vec<T>> for Array<T> {
    #[inline]
    fn from(value: Vec<T>) -> Self {
        // To make sure vec is not dropped.
        // Elements are semantically moved into the array.
        // Drop will be run (if any) when the array gets dropped.
        let mut vec = ManuallyDrop::new(value);

        // Decompose the vec into pure pointer and length.
        let len = vec.len();
        let ptr = NonNull::new(vec.as_mut_ptr())
            .expect("Vec pointer should be non-null, len correct and properly aligned");

        Self { ptr, len }
    }
}

impl<T, const N: usize> From<[T; N]> for Array<T> {
    #[inline]
    fn from(value: [T; N]) -> Self {
        let ptr = Box::into_raw(Box::new(value));
        let ptr = NonNull::new(ptr as *mut T)
            .expect("Box pointer should be non-null and properly aligned");

        Self { ptr, len: N }
    }
}

impl<T: Clone> From<&[T]> for Array<T> {
    #[inline]
    fn from(value: &[T]) -> Self {
        // Could we just memcpy everything in one shot?
        Array::from_fn(value.len(), |i| value[i].clone())
    }
}

impl<T: Clone> Clone for Array<T> {
    #[inline]
    fn clone(&self) -> Self {
        Array::from(self.as_ref())
    }
}

impl<T: Eq> Eq for Array<T> {}

impl<T: PartialEq> PartialEq for Array<T> {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.as_ref().eq(other.as_ref())
    }
}

impl<T: PartialEq> PartialEq<Vec<T>> for Array<T> {
    #[inline]
    fn eq(&self, other: &Vec<T>) -> bool {
        self.as_ref().eq(other.as_slice())
    }
}

impl<T: PartialEq> PartialEq<Array<T>> for Vec<T> {
    #[inline]
    fn eq(&self, other: &Array<T>) -> bool {
        self.as_slice().eq(other.as_ref())
    }
}

impl<T: PartialEq, const N: usize> PartialEq<[T; N]> for Array<T> {
    #[inline]
    fn eq(&self, other: &[T; N]) -> bool {
        self.as_ref().eq(other)
    }
}

impl<T: PartialEq, const N: usize> PartialEq<Array<T>> for [T; N] {
    #[inline]
    fn eq(&self, other: &Array<T>) -> bool {
        self.eq(other.as_ref())
    }
}

impl<T: Debug> Debug for Array<T> {
    #[inline]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_list().entries(self.iter()).finish()
    }
}

impl<T> Deref for Array<T> {
    type Target = [T];

    #[inline]
    fn deref(&self) -> &Self::Target {
        // Safety: Pointer is non-null and len is correct and immutable.
        unsafe { from_raw_parts(self.ptr.as_ptr(), self.len) }
    }
}

impl<T> DerefMut for Array<T> {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        // Safety: Pointer is non-null and len is correct and immutable.
        unsafe { from_raw_parts_mut(self.ptr.as_ptr(), self.len) }
    }
}

impl<T> Drop for Array<T> {
    #[inline]
    fn drop(&mut self) {
        // Safety: Pointer is non-null and len is correct and immutable.
        unsafe {
            // If the type has drop, we have to execute drop to prevent resource leaks.
            if needs_drop::<T>() {
                drop_in_place(self.as_mut());
            }

            // Memory should be freed only when we actually allocated some memory.
            if self.len != 0 && size_of::<T>() > 0 {
                let layout = Layout::array::<T>(self.len).expect("Layout should be valid");
                dealloc(self.ptr.as_ptr() as *mut u8, layout);
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use bolero::{TypeGenerator, check};
    use pastey::paste;

    // Maximum size of inputs in property based tests.
    const MAX_SIZE: usize = 1024 * 1024; // 1 MB

    /// Test with sized trivially droppable type.
    #[derive(Debug, Copy, Clone, PartialEq, Eq, TypeGenerator)]
    struct Seqno(u64);

    /// Test with type that is not trivially droppable.
    #[derive(Debug, Clone, PartialEq, Eq, TypeGenerator)]
    struct Bytes(Vec<u8>);

    /// Test with zero sized type.
    #[derive(Debug, Copy, Clone, PartialEq, Eq, TypeGenerator)]
    struct Zst;

    macro_rules! test_array {
        ($($type:ty),*) => {
            paste! {
                $(
                    #[test]
                    fn [<test_array_ $type:snake>]() {
                        check!()
                            .with_max_len(MAX_SIZE)
                            .with_type::<(Vec<$type>, $type)>()
                            .for_each(|(oracle, val)| {
                                // Create an array from oracle.
                                let mut oracle = oracle.clone();
                                let mut array = Array::from(oracle.clone());

                                // Make sure everything is equivalent to one another.
                                assert_eq!(&array, &oracle);
                                assert_eq!(format!("{oracle:?}"), format!("{array:?}"));
                                assert_eq!(format!("{oracle:#?}"), format!("{array:#?}"));

                                // Mutate elements in both.
                                for (oracle_elem, array_elem) in oracle.iter_mut().zip(array.iter_mut()) {
                                    let _ = std::mem::replace(oracle_elem, val.clone());
                                    let _ = std::mem::replace(array_elem, val.clone());
                                }

                                // Make sure updates are visible.
                                for (oracle_elem, array_elem) in oracle.iter().zip(array.iter()) {
                                    assert_eq!(oracle_elem, val);
                                    assert_eq!(array_elem, val);
                                }

                                // Make sure everything is still equivalent to one another.
                                assert_eq!(&array, &oracle);
                                assert_eq!(format!("{oracle:?}"), format!("{array:?}"));
                                assert_eq!(format!("{oracle:#?}"), format!("{array:#?}"));
                            });
                    }

                    #[test]
                    fn [<test_uninit_array_ $type:snake>]() {
                        check!()
                            .with_max_len(MAX_SIZE)
                            .with_type::<(Vec<$type>, $type)>()
                            .for_each(|(oracle, val)| {
                                // Uninitialized array
                                let mut array = Array::lazy(oracle.len());

                                // Initialize elements in the array with elements from oracle.
                                assert_eq!(array.write_from_slice(0, oracle), oracle);

                                // Modify every element.
                                let new_oracle = vec![val.clone(); oracle.len()];
                                assert_eq!(unsafe { array.overwrite_from_slice(0, &new_oracle) }, new_oracle);

                                // Make sure all the elements are correctly visible.
                                assert_eq!(unsafe { array.assume_init(0, oracle.len()) }, &new_oracle);

                                // Gotta be careful not to leak memory when using uninitialized array.
                                unsafe { array.assume_init_drop(0, oracle.len()) };
                            });
                    }
                )*
            }
        };
    }

    test_array!(Zst, Seqno, Bytes);
}
