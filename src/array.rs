//! Definition of a heap allocated array.

use std::{
    alloc::{Layout, alloc, dealloc, handle_alloc_error},
    fmt::Debug,
    mem::needs_drop,
    ops::{Deref, DerefMut},
    ptr::{self, NonNull, drop_in_place},
    slice::{from_raw_parts, from_raw_parts_mut},
};

/// A macro to initialize a the heap allocated array with an array like syntax.
///
/// # Syntax
///
/// * `array![]` create an empty array that does no heap allocations.
/// * `array![32; 5]` create an array of length 5 with all elements as 32.
/// * `array![1, 2, 3]` create an array of length 3 with elements 1, 2 and 3.
#[macro_export]
macro_rules! array {
    () => {
        $crate::Array::default()
    };

    ($elem:expr; $n:expr) => {
        $crate::Array::from_fn($n, |_| $elem)
    };

    ($($x:expr),+ $(,)?) => (
        $crate::Array::from(&[$($x),+][..])
    );
}

/// An array that uses memory allocated on the heap.
///
/// # Allocations
///
/// * Uses registered global allocator if present or std allocator.
/// * Zero sized types performs no allocations, regardless of array capacity.
/// * Array with length 0 performs no allocations.
/// * A minimum `size_of::<T> * len` bytes is allocated for the array.
pub struct Array<T> {
    len: usize,
    ptr: NonNull<T>,
}

impl<T> Array<T> {
    /// Create a new array of length zero.
    ///
    /// Note that this does not perform any heap allocation.
    #[inline]
    pub const fn new() -> Self {
        Self {
            len: 0,
            ptr: NonNull::dangling(),
        }
    }

    /// Create an array all initially filled with elements generated by a generator.
    ///
    /// # Arguments
    ///
    /// * `len` - Length of the array.
    /// * `f` - A generator of type T that gets index as argument.
    #[track_caller]
    pub fn from_fn<F>(len: usize, f: F) -> Self
    where
        F: Fn(usize) -> T,
    {
        // Zero sized types do not need heap allocations.
        if size_of::<T>() == 0 || len == 0 {
            return Self {
                len,
                ptr: NonNull::dangling(),
            };
        }

        // Allocate memory on heap to store elements of the array.
        let layout = Layout::array::<T>(len).expect("Allocation too large: > isize::MAX");
        let ptr = unsafe {
            NonNull::new(alloc(layout) as *mut T).unwrap_or_else(|| handle_alloc_error(layout))
        };

        // Write all the values generated into the array.
        for i in 0..len {
            unsafe {
                ptr::write(ptr.as_ptr().add(i), f(i));
            };
        }

        Self { ptr, len }
    }
}

unsafe impl<T: Send> Send for Array<T> {}
unsafe impl<T: Sync> Sync for Array<T> {}

impl<T> Default for Array<T> {
    #[inline]
    fn default() -> Self {
        Array::new()
    }
}

impl<'a, T> IntoIterator for &'a Array<T> {
    type Item = &'a T;
    type IntoIter = std::slice::Iter<'a, T>;

    #[inline]
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

impl<'a, T> IntoIterator for &'a mut Array<T> {
    type Item = &'a mut T;
    type IntoIter = std::slice::IterMut<'a, T>;

    #[inline]
    fn into_iter(self) -> Self::IntoIter {
        self.iter_mut()
    }
}

impl<T: Clone> From<&[T]> for Array<T> {
    #[inline]
    fn from(value: &[T]) -> Self {
        Array::from_fn(value.len(), |i| value[i].clone())
    }
}

impl<T: Clone> Clone for Array<T> {
    #[inline]
    fn clone(&self) -> Self {
        Array::from(self.as_ref())
    }
}

impl<T: Eq> Eq for Array<T> {}

impl<T: PartialEq> PartialEq for Array<T> {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.as_ref().eq(other.as_ref())
    }
}

impl<T: Debug> Debug for Array<T> {
    #[inline]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_list().entries(self.iter()).finish()
    }
}

impl<T> Deref for Array<T> {
    type Target = [T];

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { from_raw_parts(self.ptr.as_ptr(), self.len) }
    }
}

impl<T> DerefMut for Array<T> {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { from_raw_parts_mut(self.ptr.as_ptr(), self.len) }
    }
}

impl<T> Drop for Array<T> {
    #[inline]
    fn drop(&mut self) {
        unsafe {
            // If the type has drop, we have to execute drop to prevent resource leaks.
            if needs_drop::<T>() {
                drop_in_place(self.as_mut());
            }

            // Memory should be freed only when we actually allocated some memory.
            if self.len != 0 && size_of::<T>() > 0 {
                let layout = Layout::array::<T>(self.len).expect("Layout should be valid");
                dealloc(self.ptr.as_ptr() as *mut u8, layout);
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use bolero::{TypeGenerator, check};
    use rstest::rstest;
    use std::{num::NonZeroU64, ops::Bound, panic::RefUnwindSafe};

    const MAX_SIZE: usize = 1024 * 1024; // 1 MB

    /// Test with sized trivially droppable type.
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    struct Seqno(NonZeroU64);

    impl TypeGenerator for Seqno {
        fn generate<D: bolero::Driver>(driver: &mut D) -> Option<Self> {
            driver
                .gen_u64(Bound::Included(&1), Bound::Unbounded)
                .and_then(NonZeroU64::new)
                .map(Seqno)
        }
    }

    /// Test with type that is not trivially droppable.
    #[derive(Debug, Clone, PartialEq, Eq, TypeGenerator)]
    struct Bytes(Vec<u8>);

    /// Test with zero sized type.
    #[derive(Debug, Copy, Clone, PartialEq, Eq, TypeGenerator)]
    struct Zst;

    #[rstest]
    #[case(Zst)]
    #[case(Seqno(NonZeroU64::MIN))]
    #[case(Bytes(Vec::new()))]
    fn array_zero_len<T: PartialEq + Debug + Clone>(#[case] _value: T) {
        let oracle: Vec<T> = Vec::default();
        let array: Array<T> = Array::default();
        assert_eq(&oracle, &array);
    }

    #[rstest]
    #[case(Zst)]
    #[case(Seqno(NonZeroU64::MIN))]
    #[case(Bytes(Vec::new()))]
    fn array_state_machine<T: PartialEq + Debug + Clone + RefUnwindSafe + TypeGenerator>(
        #[case] value: T,
    ) {
        check!()
            .with_max_len(MAX_SIZE)
            .with_type::<Vec<Option<T>>>()
            .for_each(|oracle| {
                let mut array = Array::from(oracle.as_slice());
                let mut array_1 = Clone::clone(&array);

                // Make sure everything is equivalent to one another.
                assert_eq(&oracle, &array);
                assert_eq!(&array, &array_1);
                assert_eq!(format!("{oracle:?}"), format!("{array:?}"));
                assert_eq!(format!("{oracle:#?}"), format!("{array:#?}"));

                // Mutate all the elements in the array.
                for elem in &mut array {
                    elem.replace(value.clone());
                }

                for elem in &mut array_1 {
                    elem.take();
                }

                // Make sure update is visible correctly.
                for elem in &array {
                    assert_eq!(elem.as_ref(), Some(&value));
                }

                for elem in &array_1 {
                    assert_eq!(elem.as_ref(), None);
                }
            });
    }

    #[test]
    fn macro_empty_array() {
        let array: Array<u64> = array![];
        let oracle: Vec<u64> = vec![];
        assert_eq(&oracle, &array);
    }

    #[test]
    fn macro_from_elem() {
        let array = array![6; 10];
        let oracle = vec![6; 10];
        assert_eq(&oracle, &array);
    }

    #[test]
    fn macro_from_elems() {
        let array = array![1, 2, 3];
        let oracle = vec![1, 2, 3];
        assert_eq(&oracle, &array);
    }

    fn assert_eq<T: PartialEq + Debug>(expected: &[T], returned: &[T]) {
        assert_eq!(expected, returned)
    }
}
