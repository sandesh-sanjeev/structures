//! Definition of a heap allocated array.

use std::{
    alloc::{Layout, alloc, dealloc, handle_alloc_error},
    fmt::Debug,
    mem::needs_drop,
    ops::{Deref, DerefMut},
    ptr::{self, NonNull, drop_in_place},
    slice::{from_raw_parts, from_raw_parts_mut},
};

/// An array that uses memory allocated on the heap.
///
/// # Allocations
///
/// * Uses registered global allocator if present or std allocator.
/// * Zero sized types performs no allocations, regardless of array capacity.
/// * Array with length 0 performs no allocations.
/// * A minimum `size_of::<T> * len` bytes is allocated for the array.
pub struct Array<T> {
    len: usize,
    ptr: NonNull<T>,
}

impl<T> Array<T> {
    /// Create a new array of length zero.
    ///
    /// Note that this does not perform any heap allocation.
    pub fn new() -> Self {
        Self {
            len: 0,
            ptr: NonNull::dangling(),
        }
    }

    /// Create an array all initially filled with elements generated by a generator.
    ///
    /// # Arguments
    ///
    /// * `len` - Length of the array.
    /// * `f` - A generator of type T that gets index as argument.
    #[track_caller]
    pub fn from_fn<F>(len: usize, f: F) -> Self
    where
        F: Fn(usize) -> T,
    {
        // Zero sized types do not need heap allocations.
        if size_of::<T>() == 0 || len == 0 {
            return Self {
                len,
                ptr: NonNull::dangling(),
            };
        }

        // Allocate memory on heap to store elements of the array.
        let layout = Layout::array::<T>(len).expect("Allocation too large: > isize::MAX");
        let ptr = unsafe {
            NonNull::new(alloc(layout) as *mut T).unwrap_or_else(|| handle_alloc_error(layout))
        };

        // Write all the values generated into the array.
        for i in 0..len {
            unsafe {
                ptr::write(ptr.as_ptr().add(i), f(i));
            };
        }

        Self { ptr, len }
    }
}

impl<T> Array<Option<T>> {
    /// Create an array initially filled with [`None`].
    ///
    /// # Arguments
    ///
    /// * `len` - Length of the array.
    #[inline]
    pub fn with_none(len: usize) -> Self {
        Array::from_fn(len, |_| None)
    }
}

unsafe impl<T: Send> Send for Array<T> {}
unsafe impl<T: Sync> Sync for Array<T> {}

impl<'a, T> IntoIterator for &'a Array<T> {
    type Item = &'a T;
    type IntoIter = std::slice::Iter<'a, T>;

    #[inline]
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

impl<'a, T> IntoIterator for &'a mut Array<T> {
    type Item = &'a mut T;
    type IntoIter = std::slice::IterMut<'a, T>;

    #[inline]
    fn into_iter(self) -> Self::IntoIter {
        self.iter_mut()
    }
}

impl<T: Clone> From<&[T]> for Array<T> {
    #[inline]
    fn from(value: &[T]) -> Self {
        Array::from_fn(value.len(), |i| value[i].clone())
    }
}

impl<T: Clone> Clone for Array<T> {
    #[inline]
    fn clone(&self) -> Self {
        Array::from(self.as_ref())
    }
}

impl<T: Debug> Debug for Array<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_list().entries(self.iter()).finish()
    }
}

impl<T> Deref for Array<T> {
    type Target = [T];

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { from_raw_parts(self.ptr.as_ptr(), self.len) }
    }
}

impl<T> DerefMut for Array<T> {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { from_raw_parts_mut(self.ptr.as_ptr(), self.len) }
    }
}

impl<T> Drop for Array<T> {
    #[inline]
    fn drop(&mut self) {
        unsafe {
            // If the type has drop, we have to execute drop to prevent resource leaks.
            if needs_drop::<T>() {
                drop_in_place(self.as_mut());
            }

            // Memory should be freed only when we actually allocated some memory.
            if self.len != 0 && size_of::<T>() > 0 {
                let layout = Layout::array::<T>(self.len).expect("Layout should be valid");
                dealloc(self.ptr.as_ptr() as *mut u8, layout);
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use bolero::{TypeGenerator, check, generator};
    use std::{num::NonZeroU64, ops::Bound};

    const MAX_SIZE: usize = 1024 * 1024; // 1 MB

    #[derive(Debug, Clone, PartialEq, Eq)]
    struct Seqno(NonZeroU64);

    impl Drop for Seqno {
        fn drop(&mut self) {
            self.0 = self.0.saturating_add(5);
        }
    }

    impl TypeGenerator for Seqno {
        fn generate<D: bolero::Driver>(driver: &mut D) -> Option<Self> {
            driver
                .gen_u64(Bound::Unbounded, Bound::Unbounded)
                .and_then(NonZeroU64::new)
                .map(Seqno)
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq, TypeGenerator)]
    struct Zst;

    impl Drop for Zst {
        fn drop(&mut self) {
            let _ = 5 + 5;
        }
    }

    #[test]
    fn seq_no_zero_len() {
        let elements: Vec<Seqno> = Vec::new();
        let array: Array<Seqno> = Array::new();

        assert_eq(&elements, &array);
        assert_eq!(format!("{elements:?}"), format!("{array:?}"));
    }

    #[test]
    fn seq_no_with_none() {
        check!()
            .with_generator(generator::produce::<usize>().with().bounds(1..1024))
            .for_each(|size| {
                let elements = vec![None; *size];
                let array = Array::<Option<Seqno>>::with_none(*size);

                assert_eq(&elements, &array);
                assert_eq!(format!("{elements:?}"), format!("{array:?}"));
            });
    }

    #[test]
    fn zst_zero_len() {
        let elements: Vec<Zst> = Vec::new();
        let array: Array<Zst> = Array::new();

        assert_eq(&elements, &array);
        assert_eq!(format!("{elements:?}"), format!("{array:?}"));
    }

    #[test]
    fn zst_with_none() {
        check!()
            .with_generator(generator::produce::<usize>().with().bounds(1..1024))
            .for_each(|size| {
                let elements = vec![None; *size];
                let array = Array::<Option<Zst>>::with_none(*size);

                assert_eq(&elements, &array);
                assert_eq!(format!("{elements:?}"), format!("{array:?}"));
            });
    }

    #[test]
    fn seq_no_arbitrary() {
        check!()
            .with_max_len(MAX_SIZE)
            .with_type::<Vec<Seqno>>()
            .for_each(|elements| {
                let mut array = Array::from(elements.as_slice());
                assert_eq(&elements, &array);
                assert_eq!(format!("{elements:?}"), format!("{array:?}"));

                // Mutate all the elements in the array.
                for elem in &mut array {
                    elem.0 = NonZeroU64::MAX;
                }

                // Make sure update is visible correctly.
                for elem in &array {
                    assert_eq!(elem.clone(), Seqno(NonZeroU64::MAX));
                }

                // Clone array and make sure equal to base array.
                let array_clone = array.clone();
                assert_eq(&array, &array_clone);
            });
    }

    #[test]
    fn zst_arbitrary() {
        check!()
            .with_max_len(MAX_SIZE)
            .with_type::<Vec<Zst>>()
            .for_each(|elements| {
                let mut array = Array::from(elements.as_slice());
                assert_eq(&elements, &array);
                assert_eq!(format!("{elements:?}"), format!("{array:?}"));

                // Mutate all the elements in the array.
                for elem in &mut array {
                    std::mem::swap(elem, &mut Zst);
                }

                // Make sure update is visible correctly.
                for elem in &array {
                    assert_eq!(elem, &Zst);
                }
            });
    }

    fn assert_eq<T: PartialEq + Debug>(expected: &[T], returned: &[T]) {
        assert_eq!(expected, returned)
    }
}
